\chapter{FFI}

\textbf{Foreign Function Interface} (FFI) is an interface for interaction between different languages. Berry provides a set of FFI to realize the interaction with C language, this set of interfaces is also very easy to use in C++. Most of the FFI interfaces are functions, and their declarations are placed in the \textsl{berry.h} file. In order to reduce the amount of RAM used, FFI also provides a mechanism for generating a fixed hash table during C compilation. This mechanism must use external tools to generate C code.

\section {Basics}

The most important interactive function in FFI should be the function of calling Berry code and C function mutually. In order to realize that two languages   call each other's functions, we must first understand the parameter passing mechanism of the Berry function.

\subsection {Virtual Machine}

Unlike compiled languages, Berry language cannot run directly on a physical machine, but in a specific software environment, which is \textbf{Virtual Machine} (VM). Similar to a real computer, the source code in text form cannot be executed in a virtual machine, but must be converted into "bytecode" by a compiler. The Berry virtual machine is defined as a C structure \texttt{bvm}, the content of this structure is invisible to FFI. Through some FFI functions, we can create and initialize a virtual machine. We introduce the use of virtual machines through a simple example:
\begin{lstlisting}[language=c, style=berry]
void berry_test(void)
{
    bvm *vm = be_vm_new(); // Construct a VM
    be_loadstring(vm, "print('Hello Berry')"); // Compile test code
    be_pcall(vm, 0); // Call function
    be_vm_delete(vm); // Destroy the VM
}
\end{lstlisting}
This code gives a complete example of using a virtual machine. First, call the function \texttt{be\_vm\_new} to construct a new virtual machine, and then all operations are completed in this virtual machine object. \texttt{be\_vm\_new} The function will automatically link the standard library when creating a virtual machine. The function of lines 4 to 5 is to compile the source code in a string into a Berry function and then call it. Finally, call the \texttt{be\_vm\_delete} function on line 6 to destroy the virtual machine. Executing this function will get a line of output in the terminal:
\begin{lstlisting}[numbers=none]
Hello Berry
\end{lstlisting}

In all scenarios, the virtual machine construction, library loading and destruction process are the same as the 3rd, 4th and 6th lines in the above example. If necessary, the way to compile or load the source code may be different. For example, for the source code in the form of a file, it can be compiled through the \texttt{be\_loadfile} function. The source code will be compiled into a Berry function, and the function will be stored on the top of the stack. The Berry function can be executed by calling the FFI function \texttt{be\_pcall} or \texttt{be\_call}. You can also use the REPL through the \texttt{be\_repl} function. The interface of the REPL will be described in the relevant chapters.

\subsection {Virtual Stack}

Berry uses a virtual stack and native functions written in C to pass values. Each element in the stack is a Berry value. When Berry code calls a native function, it always creates a new stack and pushes all the parameters onto the stack. This virtual stack can also be used in C code to store data, and the value stored in the stack will not be reclaimed by the garbage collector.

\begin{wrapfigure}{r}{0.5\textwidth}
\centering
\begin{tikzpicture}
    \begin{scope}[
    start chain=1 going right,start chain=2 going below,node distance=-0.15mm,minimum width=0.5cm,minimum height=0.6cm,font=\small\ttfamily
  ]
  \node [on chain=1] at (-1.5, -0.4) {\ldots};
  \foreach \x in {-1,...,-7} {
      \x, \node at (3+\x*0.5, 0.2) {\x};
  }
  \node [draw,on chain=1] {};
  \foreach \x in {1,...,7} {
      \x, \node (\x) [draw,on chain=1] {\x};
  }
  \foreach \x in {8,...,10} {
      \x, \node (\x) [draw,on chain=1] {};
  }
  \node [on chain=1] {\ldots};
  \node (base) at (-0.5, -1.2) {base};
  \node (top)  at (3, -1.2) {top};

  \draw[->] (base) -- (1);
  \draw[->] (top) -- (8);
  \end{scope}
\end{tikzpicture}
\caption{Virtual stack}
\label{fig::virtual_stack}
\end{wrapfigure}

The virtual stack used by Berry is shown in Figure \ref{fig::virtual_stack}. The virtual stack grows from left to right. When Berry code calls a native function, it will get an initial stack. The position of the first value of the stack is called \textbf{base}, and the last position is called \textbf{top}, the native function Only the value from the bottom of the stack to the position before the top of the stack can be accessed. The position of the bottom of the stack is fixed, while the position of the top of the stack can be moved, and the top of the stack is always empty. The reason for this property is that after the new value is pushed into the virtual stack, the original position of the top of the stack will be written The new value, the top pointer of the stack will move forward to the next position; conversely, if the value at the top of the virtual stack is popped, the top pointer of the stack will decrease $1$. At this time, although the position of the top pointer of the stack is objectively Value, but this value is invalid and may be cleared at any time, so the pointer position on the top of the stack is still empty. When the virtual stack is empty, the bottom pointer \texttt{base} is equal to the top pointer \texttt{top}. The virtual stack does not strictly follow the operating rules of the stack: in addition to push and pop, the virtual stack can also be accessed by index, and even insert or delete values   at any position. There are two ways to index elements in the stack: one is based on the bottom of the stack \textbf{Absolute index}, the absolute index value is a positive integer starting from $1$; the other is based on the top of the stack \textbf{Relative index}, The relative index value is a negative integer starting from $-1$. Take Figure \ref{fig::virtual_stack} as an example, the index value $1,2\ldots 8$ is an absolute index, and the absolute index of an element is the distance from the element to the bottom of the stack. The index value $-1,-2\ldots -8$ is a relative index, and the relative index value of an element is the negative number of the distance from the element to the top of the stack. If an index value $index$ is valid, then the element it refers to should be between the bottom of the stack and the top of the stack, which means that the expression $1\leqslant \mathrm{abs}(index)\leqslant top-base+1$ is satisfied.

For convenience, we stipulate that the stack bottom pointer \texttt{base} is used as a reference, and its absolute index $1$, and the previous value of \texttt{base} is not considered (usually, \texttt{base} is not the bottom position of the entire stack). For example, when a native function returns, the location where the return value is stored is just before \texttt{base}, and these locations are usually not accessible by the native function.

\subsection {Operate Virtual Stack}

\subsubsection {Index and stack size}

As mentioned earlier, two indexing methods can be used to access the virtual stack, and the index value must be valid. At the same time, in many cases it is also necessary to push new values   onto the stack. In this case, the programmer must ensure that the stack will not overflow. By default, Berry guarantees \texttt{BE\_STACK\_FREE\_MIN} space for native functions to use. This value can be modified in the file \textsl{berry.h}. Its default value is usually $10$, which should be sufficient in most cases. If you really need to expand the stack, you can call the FFI function \texttt{be\_stack\_require}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_stack_require(bvm *vm, int count);
\end{lstlisting}
The parameter \texttt{count} is the amount of space needed. When the remaining space in the virtual stack is insufficient, the stack capacity will be expanded, otherwise this function will do nothing.

\textbf{caveat}: If a stack overflow occurs, or if an invalid index is used to access the stack, the program will crash. You can turn on the debugging switch \texttt{BE\_DEBUG} (section \ref{section::BE_DEBUG}), which will turn on the assertion function, and you can get some debugging information at runtime to catch errors such as stack overflow or invalid index.

\subsubsection {Get value from stack}There is a set of functions in FFI to get values   from the virtual stack. These functions usually convert the values   in the stack into simple values   supported by the C language and then return. The following are commonly used FFIs to get values   from the stack:
\begin{lstlisting}[language=c, style=berry, numbers=none]
bint be_toint(bvm *vm, int index);
breal be_toreal(bvm *vm, int index);
int be_tobool(bvm *vm, int index);
const char* be_tostring(bvm *vm, int index);
void* be_tocomptr(bvm *vm, int index);
\end{lstlisting}
The parameter form of these functions is the same, but the return value is different. The first four functions are easy to understand. Just like their names, the function of \texttt{be\_toint} is to convert the values   in the virtual stack to C integer values   (\texttt{bint} is usually an alias of type \texttt{int}) and return. The function of the last function \texttt{be\_tocomptr} is to take out a pointer value of a general type from the virtual stack. The specific meaning of this pointer is explained by the C program itself.

These functions use the same way to interpret the parameters: the parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the element to be retrieved, which can be a relative index or an absolute index. You cannot use FFI to remove Berry's complex data types from the virtual stack, so you cannot remove a \texttt{map} type or \texttt{class} type from the stack. One of the benefits of this design is that there is no need to consider garbage collection in native functions.

\subsection{Native function}

\textbf{Native function} It is implemented by C language and can be called by Berry code. The native function can be an ordinary function. In this case, calling the native function will not generate any dynamically allocated space, just like a normal C function call. Native functions can also be closures, and space needs to be allocated for free variables when creating native closures. Under normal circumstances, simple native functions are sufficient to meet the needs. They save resources than native closures and are easier to use.

\subsubsection{Define native function}

The native function itself is a C function, but they all have a specific form. The definition of the native function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int a_native_function(bvm *vm)
{
    // do something ...
}
\end{lstlisting}
The native function must be a C function whose parameter is a pointer to \texttt{bvm} and the return value is \texttt{int}. Berry's functions must return a value, and native functions are no exception. Unlike the return value of the C language, the return value of the native function is not the value carried by the C \texttt{return} statement. You can use these FFIs to return the value of the native function, and they also make the C function return:
\begin{lstlisting}[language=c, style=berry, numbers=none]
be_return(bvm *vm);
be_return_nil(bvm *vm);
\end{lstlisting}
These FFIs are actually two macros, and there is no need to use the C \texttt{return} statement when using them. \texttt{be\_return} Will put the top of the virtual stack

\subsubsection{Use native function}

After the native function is defined, it must be added to the interpreter in some way before it can be called in Berry code. One of the easiest ways is to add native functions to Berry's built-in object table. The process of setting native objects as Berry built-in objects is called \textbf{registered}. The FFI of the registered native function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_regfunc(bvm *vm, const char *name, bntvfunc f);
\end{lstlisting}
\texttt{vm} is the current virtual machine instance, \texttt{name} is the name of the native function, and \texttt{f} is the pointer of the native function. The specific behavior of this function is related to the value of the \texttt{BE\_USE\_PRECOMPILED\_OBJECT} macro (although the FFI is still available when using the compile-time construction technique, it cannot dynamically register the built-in variables. In this case, please refer to the method of registering the built-in objects. \ref{section::precompiled_build}). The definition of native function type \texttt{bntvfunc} is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int (*bntvfunc)(bvm*);
\end{lstlisting}
In fact, the \texttt{bntvfunc} type is the function pointer type with the parameter \texttt{bvm} and the return value type \texttt{int}. \texttt{be\_regfunc} The function should be called before parsing the Berry source code.

You can also push the native function into the virtual stack, and then use an FFI function \texttt{be\_call} to call it. A more common usage is to use the native function object in the virtual stack as the return value.

\subsubsection {Complete example}We end this section with a simple example. Here, we are going to implement a \texttt{add} function that adds two numbers and returns the result of the calculation. First, we define a native function to implement this function:
\begin{lstlisting}[language=c, style=berry]
static int l_add(bvm *vm)
{
    int top = be_top(vm); // Get the number of arguments
    /* Verify the number and type of arguments */
    if (top == 2 && be_isnumber(vm, 1) && be_isnumber(vm, 2)) {
        breal x = be_toreal(vm, 1); // Get the first argument
        breal y = be_toreal(vm, 2); // Get the second argument
        be_pushreal(vm, x + y); // Push the result onto the stack
        be_return(vm); // Return the value at the top of the stack
    }
    be_return_nil(vm); // Return nil when something goes wrong
}
\end{lstlisting}
Native functions usually do not need to be used outside the C file, so they are generally declared as \texttt{static} types. Use the \texttt{be\_top} function to get the absolute index of the top of the virtual stack (\texttt{top} value), which is the capacity of the stack. We can call \texttt{be\_top} before the native function performs the virtual stack operation, at this time the virtual stack capacity is equal to the real parameter amount. For the \texttt{add} function, we need two parameters to participate in the operation, so check whether the number of parameters is 2 in the fourth line (\texttt{top == 2}). And we need to check whether the two parameters are both numeric types, so we need to call the \texttt{be\_isnumber} function to check. If everything is correct, the parameters will be taken out of the virtual stack, then the calculation result will be pushed onto the stack, and finally returned using \texttt{be\_return}. If the parameter verification fails, \texttt{be\_return\_nil} will be called to return the value of \texttt{nil}.

Next, register this native function to the built-in object table. For simplicity, we register it after loading the library:
\begin{lstlisting}[language=c, style=berry]
bvm *vm = be_vm_new(); // Construct a VM
be_regfunc(vm, "myadd", l_add); // Register the native function "myadd"
\end{lstlisting}
The second line is where the native function is registered, and we named it \texttt{myadd}. At this point, the definition and registration of the native function is complete. As a verification, you can compile the interpreter, then enter the REPL and run some tests. You should get results like this:
\begin{lstlisting}[language=berry, numbers=none]
> myadd
<function: 0x562a210f0f90>
> myadd(1.0, 2.5)
3.5
> myadd(2.5, 2)
4.5
> myadd(1, 2)
3
\end{lstlisting}

\section {Types and Functions}

\subsection {Type}

This section will introduce some types that need to be used in FFI. These types are generally used by FFI functions. Generally, the types and declarations in FFI can be found in the \textsl{berry.h} file. Unless otherwise specified in this section, the definition or declaration is provided in \textsl{berry.h} by default.

\ffititle{bvm}

\texttt{bvm} Type is used to store the state information of the Berry virtual machine. Details of this type are not visible to external programs. Therefore, this definition can only be found in the \textsl{berry.h} file:
\begin{lstlisting}[language=c, numbers=none]
typedef struct bvm bvm;
\end{lstlisting}

Most FFI functions use the \texttt{bvm} type as the first parameter, because they all operate on the virtual machine internally. Hiding the internal implementation of \texttt{bvm} helps reduce the coupling between the FFI standard and the VM. Outside the interpreter, usually only \texttt{bvm} pointers are used. To create a new \texttt{bvm} object, use the \texttt{be\_vm\_new} function, and destroy the \texttt{bvm} object using the \texttt{be\_vm\_delete} function.

\ffititle{bntvfunc}Native function type. The definition of this type is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int (*bntvfunc)(bvm*);
\end{lstlisting}
This type is a native function pointer, and some FFIs that register or add native functions to the virtual machine use parameters of this type. Variables or parameters of this type need to be initialized with a function name whose parameter is of type \texttt{bvm} and whose return value is of type \texttt{int}.

\ffititle{bnfuncinfo}

This type is used when registering native functions in batches or building native classes. It is defined as:
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef struct {
    const char *name; // The name of the function or object
    bntvfunc function; // The function pointer
} bnfuncinfo;
\end{lstlisting}
The \texttt{name} member of \texttt{bnfuncinfo} represents the name of a function or object, and the \texttt{function} member is a native function pointer.

\ffititle{bint}

This type is a built-in integer type of Berry. It is defined in the \textsl{berry.h} document. By default, \texttt{bint} is implemented using the \texttt{long long} type, and the implementation of \texttt{bint} can be modified by modifying the configuration file.

\ffititle{breal}

This is Berry's built-in real number type, which is actually the floating point type in C language. \texttt{breal} is defined as:
\begin{lstlisting}[language=c, style=berry, numbers=none]
#if BE_SINGLE_FLOAT != 0
    typedef float breal;
#else
    typedef double breal;
#endif
\end{lstlisting}
You can use the macro \texttt{BE\_SINGLE\_FLOAT} to control the specific implementation of \texttt{breal}: when the value of \texttt{BE\_SINGLE\_FLOAT} is \texttt{0}, the \texttt{double} type implementation \texttt{breal} will be used, otherwise the \texttt{float} type implementation \texttt{breal} will be used.

\ffititle{berrorcode} \label{section::errorcode}

This enumeration type is used in some FFI return values. The definition of this type is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
enum berrorcode {
    BE_OK = 0,
    BE_IO_ERROR,
    BE_SYNTAX_ERROR,
    BE_EXEC_ERROR,
    BE_MALLOC_FAIL,
    BE_EXIT
};
\end{lstlisting}
The meaning of these enumeration values   are:
\begin{itemize}
    \item \texttt{BE\_OK}: There is no error, the function is executed successfully.
    \item \texttt{BE\_IO\_ERROR}: A file reading error occurred when the interpreter was reading the source file. The error is generally caused by the absence of the file.
    \item \texttt{BE\_SYNTAX\_ERROR}: A syntax error occurred when the interpreter was compiling the source code. After this error occurs, the interpreter will not generate bytecode, so it cannot continue to execute bytecode.
    \item \texttt{BE\_EXEC\_ERROR}: Runtime error. When this error occurs, execution of Berry code is stopped and the environment is restored to the most recent recovery point.
    \item \texttt{BE\_MALLOC\_FAIL}: Memory allocation failed. This error is caused by insufficient heap space.
    \item \texttt{BE\_EXIT}: Indicates that the program exits and the enumeration value is not an error. Executing Berry's \texttt{exit} function causes the interpreter to return this value.
\end{itemize}

It should be noted that when a \texttt{BE\_MALLOC\_FAIL} error occurs, dynamic memory allocation can no longer be performed, which means that string objects can no longer be allocated, so the function that returns this error usually does not give more detailed error information.

\subsection {Functions and Macros}

\ffititle{be\_vm\_new}

This function is used to create a new virtual machine instance. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
bvm* be_vm_new(void);
\end{lstlisting}
The return value of the function is a pointer to the virtual machine instance. \texttt{{be\_vm\_new}} The number is the first function called when the Berry interpreter is created. This function will do a lot of work: apply for memory for the virtual machine, initialize the state and attributes of the virtual machine, initialize the GC (garbage collector), and The standard library is loaded into the virtual machine instance, etc.

\ffititle{be\_vm\_delete}This function is used to destroy a virtual machine instance, the function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_vm_delete(bvm *vm);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine object to be destroyed. Destroying the virtual machine will release all the objects in the virtual machine, including the values   in the stack and the objects managed by the GC. The virtual machine pointer after destruction will be an invalid value, and it can no longer be referenced.

\ffititle{be\_loadbuffer}

This function is used to load a piece of source code from the buffer and compile it into bytecode. The prototype of the function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_loadbuffer(bvm *vm, const char *name, const char *buffer, size_t length);
\end{lstlisting}
The parameter \texttt{vm} is the virtual machine pointer. \texttt{name} is a string, which is usually used to mark the source of the source code. For example, the source code input from the standard input device can pass the string \texttt{"stdin"} to this parameter, and the source code input from the file can be The file name is passed to this parameter. \texttt{buffer} The parameter is the buffer for storing the source code. The organization of this buffer is very similar to the string of C. It is a continuous sequence of characters, but the buffer pointed to by \texttt{buffer} does not require \texttt{'\textbackslash 0'} characters as Terminator. \texttt{length} The parameter indicates the length of the buffer. This length refers to the number of bytes of source code text in the buffer.

To give a simple example, if we want to use the \texttt{be\_loadbuffer} function to compile a string, the general usage is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
const char *str = "print('Hello Berry')";
be_loadbuffer(vm, "string", str, strlen(str));
\end{lstlisting}
Here we use the string \texttt{"string"} to represent the source code, you can also modify it to any value. Note that the C standard library function \texttt{strlen} function is used here to get the length of the string buffer (actually the number of bytes in the string).

If the compilation is successful, \texttt{be\_loadbuffer} will compile the source code into a Berry function and place it on the top of the virtual stack. If the compilation encounters an error, \texttt{be\_loadbuffer} will return an error value of type \texttt{berrorcode} (Section \ref{section::errorcode}), and if possible, will store the specific error message string at the top of the virtual stack.

\ffititle{be\_loadstring}

\texttt{be\_loadstring} is a macro defined as:
\begin{lstlisting}[language=c, style=berry, numbers=none]
#define be_loadstring(vm, str) be_loadbuffer((vm), "string", (str), strlen(str))
\end{lstlisting}
This macro is just a simple wrapper for the \texttt{be\_loadbuffer} function. \texttt{vm} The parameter is a pointer to the virtual machine instance, and the \texttt{str} parameter is a pointer to the source code string. It is very convenient to use \texttt{be\_loadstring} to compile strings, for example:
\begin{lstlisting}[language=c, style=berry, numbers=none]
be_loadstring(vm, "print('Hello Berry')");
\end{lstlisting}
This way of writing is more concise than using \texttt{be\_loadbuffer}, but you must ensure that the string ends with a \texttt{'\textbackslash 0'} character.

\ffititle{be\_loadfile}

This function is used to compile a source code file. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_loadfile(bvm *vm, const char *name);
\end{lstlisting}
The function of this function is similar to the \texttt{be\_loadbuffer} function, except that the function will be compiled by reading the source code file. The parameter \texttt{vm} is the pointer of the virtual machine instance, and the parameter \texttt{name} is the file name of the source file. This function will call the file interface, and by default it will use functions such as \texttt{fopen} in the C standard library to manipulate files.

If you use the file interface of the C standard library, you can use relative path or absolute path file names. If the file does not exist, \texttt{be\_loadfile} will return a \texttt{BE\_IO\_ERROR} error (section \ref{section::errorcode}) and push the error message onto the top of the stack. Other error messages are the same as the \texttt{be\_loadbuffer} function. It is recommended to use the \texttt{be\_loadfile} function to compile the source file, instead of reading all the source files into a buffer, and then call the \texttt{be\_loadbuffer} function to compile the source code. The former will read the source file in segments and only create a small read buffer in the memory, thus saving more memory.

\ffititle{be\_top}This function returns the absolute index value of the top element in the virtual stack. This value is also the number of elements in the virtual stack (the capacity of the virtual stack). Call this function before adding or subtracting elements in the virtual stack to get the number of parameters of the native function. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_top(bvm *vm);
\end{lstlisting}

This function is usually used to obtain the number of parameters of a native function. When used for this purpose, it is recommended to call \texttt{be\_top} at the top of the native function body. E.g:
\begin{lstlisting}[language=c, style=berry, numbers=none]
static int native_function_example(bvm *vm)
{
    int argc = be_top(vm); // Get the number of arguments
    // ...
}
\end{lstlisting}

\ffititle{be\_typename}

This function converts the type of the Berry object into a string and returns it. For example, it returns \texttt{"int"} for an integer object, and \texttt{"function"} for a function object. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
const char* be_typename(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the object to be operated. The \texttt{type} function in the Berry standard library is implemented by calling \texttt{be\_typename}. Please refer to section \ref{section::baselib_type} for the return string corresponding to the parameter type.

\ffititle{be\_classname}

This function is used to get the class name of an object or class. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
const char* be_classname(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the object to be operated. If the value at \texttt{index} is an instance, the \texttt{be\_classname} function will return the class name string to which the instance belongs, and if the value at \texttt{index} is a class, it will directly return the class name string. In other cases \texttt{be\_classname} will return \texttt{NULL}.

\ffititle{be\_strlen}

This function returns the length of the specified Berry string. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_strlen(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the object to be operated. This function returns the number of bytes in the string at \texttt{index} (the \texttt{'\textbackslash 0'} characters at the end of the Berry string are not counted). If the value of the \texttt{index} position is not a string, the \texttt{be\_strlen} function will return \texttt{0}.

Although the \texttt{Berry} string is compatible with the C string format, it is not recommended to use the \texttt{strlen} function of the C standard library to measure the length of the Berry string. For Berry strings, \texttt{be\_strlen} is faster than \texttt{strlen} and has better compatibility.

\ffititle{be\_strconcat}

This function is used to splice two Berry strings. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_strconcat(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance. This function will concatenate the string at the parameter position of \texttt{index} with the string at the top position of the stack, and then put the resulting string into the position indexed by \texttt{index}.

\ffititle{be\_pop}

This function pops the value at the top of the stack. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pop(bvm *vm, int n);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and the parameter \texttt{n} is the number of values   to be popped from the stack. Note that the value of \texttt{n} cannot exceed the capacity of the stack.

\ffititle{be\_remove}

This function will remove a value from the stack. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_remove(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and the parameter \texttt{index} is the index of the object to be removed. After the value at \texttt{index} is moved out, the following values   will be filled forward, and the stack capacity will be reduced by one. The value of \texttt{index} cannot exceed the capacity of the stack.

\ffititle{be\_absindex}This function returns the absolute index value of a given index value, and its function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_absindex(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and the parameter \texttt{index} is the input index value. If \texttt{index} is positive, the return value of \texttt{be\_absindex} is the value of \texttt{index}. If \texttt{index} is negative, the return value of texttt{be\_absindex} is the absolute index value corresponding to \texttt{index}. When \texttt{index} is a negative value (relative index), its index position cannot be lower than the bottom of the stack.

\ffititle{be\_newlist}

This function creates a new \texttt{list} value, and its function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_newlist(bvm *vm);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance. After this function is successfully called, the new \texttt{list} value will be pushed onto the top of the stack.

\ffititle{be\_newmap}

This function creates a new \texttt{map} value, and its function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_newmap(bvm *vm);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance. After this function is successfully called, the new \texttt{map} value will be pushed onto the top of the stack.

\ffititle{be\_getglobal}

This function pushes the global variable with the specified name onto the stack. Its function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getglobal(bvm *vm, const char *name);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and the parameter \texttt{name} is the name of the global variable. After this function is called, the global variable named \texttt{name} will be pushed onto the top of the virtual stack.

\ffititle{be\_setmember}

This function is used to set the value of the member variable of the instance object class. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_setmember(bvm *vm, int index, const char *k);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, the parameter \texttt{index} is the index of the instance object, and the parameter \texttt{k} is the name of the member. This function will copy the value at the top of the stack to the member \texttt{k} of the index position instance. Note that the top element of the stack will not pop up automatically.

\ffititle{be\_getmember}

This function is used to get the value of the member variable of the instance object class. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getmember(bvm *vm, int index, const char *k);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, the parameter \texttt{index} is the index of the instance object, and the parameter \texttt{k} is the name of the member. This function pushes the value of the member of the index position instance \texttt{k} onto the top of the virtual stack.

\ffititle{be\_getindex}

This function is used to get the value of \texttt{list} or \texttt{map}. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getindex(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and the parameter \texttt{index} is the index of the object to be operated. This function is used to get an element from the \texttt{map} or \texttt{list} container, and the index of the element is stored at the top of the stack (relative index is $-1$). After calling this function, the value obtained from the container will be pushed onto the top of the stack. If there is no subscript pointed to by the container, the value of \texttt{nil} will be pushed onto the top of the stack. For example, if the element with index $1$ in the virtual stack is a \texttt{list}, and we want to extract the element with index $0$ from it, then we can use the following code:\begin{lstlisting}[language=c, style=berry]
be_pushint(vm, 0); // Push the index value 0 onto the virtual-stack
be_getindex(vm, 1); // Get an element from the list container
\end{lstlisting}
We first push the integer value \texttt{0} onto the stack, and this value will be used as the index to get the element from the \texttt{list} container. The second line of code implements to get elements from the \texttt{list} container. The index value of the \texttt{list} container in the example is $1$ in the virtual stack. The retrieved element is stored at the top of the stack, and we can use the relative index $-1$ to access it.

\ffititle{be\_setindex}

This function is used to set a value in \texttt{list} or \texttt{map}. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_setindex(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and the parameter \texttt{index} is the subscript of the object to be operated. This function is used to write an element of the \texttt{map} or \texttt{list} container. The index of the value to be written in the virtual stack is $-1$, and the index of the subscript of the write position in the virtual stack is $-2$. If the element with the specified subscript does not exist in the container, the write operation will fail.

Assuming that the position with index \texttt{1} in the virtual stack has a value of \texttt{map}, and it has an element with a subscript of \texttt{"test"}, an example of setting the element at the subscript of \texttt{"test"} to \texttt{100} is:
\begin{lstlisting}[language=c, style=berry]
be_pushstring(vm, "test"); // Push the index "index"
be_pushint(vm, 100); // Push the value 100
be_setindex(vm, 1); // Set the key-value pair to map["test"] = 100
\end{lstlisting}
We must first push the subscript and the value to be written on the stack in order. For \texttt{map}, it is a key-value pair. In the example, the first two lines of code complete these tasks. The third line calls the \texttt{be\_setindex} function to write the value into the \texttt{map} object.

\ffititle{be\_getupval}

This function is used to read an Up Value of the native closure. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getupval(bvm *vm, int index, int pos);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the native closure index value of the Up Value to be read; \texttt{pos} is the position of the Up Value in the native closure Up Value table (numbering starts from 0). The read Up Value will be pushed onto the top of the virtual stack.

\ffititle{be\_setupval}

This function is used to set an Up Value of the native closure. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_setupval(bvm *vm, int index, int pos);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the native closure index value to be written into the Up Value; \texttt{pos} is the position of the Up Value in the native closure Up Value table (numbering starts from 0). This function obtains a value from the top of the virtual stack and writes it to the target Up Value. After the operation is completed, the top value of the stack will not be popped from the stack.

\ffititle{be\_getsuper}

This function is used to get the parent object of the base class or instance of the class. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getsuper(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the class or object to be operated. If the value at \texttt{index} is a class with a base class, the function will push its base class onto the top of the stack; if the value at \texttt{index} is an object with a parent object, the function will take its parent The object is pushed onto the top of the stack; otherwise, a value of \texttt{nil} is pushed onto the top of the stack.

\ffititle{be\_data\_size}This function is used to get the number of elements contained in the container. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_data_size(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the container object to be operated. If the value at \texttt{index} is a Map value or List value, the function returns the number of elements contained in the container, otherwise it returns \texttt{-1}.

\ffititle{be\_data\_push}

This function is used to append a new element to the end of the container. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_data_push(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the container object to be operated. The object at \texttt{index} must be a List value. This function gets a value from the top of the stack and appends it to the end of the container. After the operation is completed, the value at the top of the stack will not be popped from the stack.

\ffititle{be\_data\_insert}

This function is used to insert a pair of elements into the container. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_data_insert(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the container object to be operated. The object at \texttt{index} must be a List value or a Map value. The inserted element forms a pair of key-value pairs. The value is stored at the top of the stack, and the key is stored at the previous index on the top of the stack. It should be noted that the key inserted into the Map container cannot be a \texttt{nil} value, and the key inserted into the List container must be an integer value. If the operation is successful, the function will return \texttt{bture}, otherwise it will return \texttt{bfalse}.

\ffititle{be\_data\_remove}

This function is used to remove an element in the container. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_data_remove(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the container object to be operated. The object at \texttt{index} must be a List value or Map value. For the Map container, the key to delete the element is stored on the top of the virtual stack (need to be pressed before the function call); for the List container, the index of the element to be deleted is stored on the top of the virtual stack (need to be before the function call) push into). If the operation is successful, the function will return \texttt{bture}, otherwise it will return \texttt{bfalse}.

\ffititle{be\_data\_resize}

This function is used to reset the capacity of the container. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_data_resize(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the container object to be operated. This function is only available for List containers, and the new capacity is stored on the top of the virtual stack (must be an integer).

\ffititle{be\_iter\_next}

This function is used to get the next element of the iterator. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_iter_next(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the iterator to be operated. The iterator object may be an iterator of a List container or a Map container. For the List iterator, this function pushes the iteration result value onto the top of the stack, while for the Map iterator, it pushes the key value into the previous position and the top of the stack respectively. Calling this function will update the iterator. If the function returns \texttt{0}, the call fails, returning \texttt{1} to indicate that the current iterator is a List iterator, and returning \texttt{2} to indicate that the current iterator is a Map iterator.

\ffititle{be\_iter\_hasnext}

This function is used to test whether there is another element in the iterator. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int map_hasnext(bvm *vm, int index)
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the iterator to be operated. The iterator object may be an iterator of a List container or a Map container. If there are more iterable elements in the iterator, return \texttt{1}, otherwise return \texttt{0}.

\ffititle{be\_refcontains}This function is used to test whether there is a reference to the specified object in the reference stack. It must be used in conjunction with \texttt{be\_refpush} and \texttt{be\_refpop}. This API can avoid recursion when traversing objects that have their own references. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_refcontains(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the object to be operated. This function is used for the value of an instance type. If there is a reference to the object in the reference stack, it returns \texttt{1}, otherwise it returns \texttt{0}.

\ffititle{be\_refpush}

Push the reference of the specified object onto the reference stack. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_refpush(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{index} is the index of the object to be operated. This function is used for the value of an instance type.

\ffititle{be\_refpop}

Pop the object at the top of the reference stack. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_refpop(bvm *vm);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance. This function is used in pairs with \texttt{be\_refpush}. The following is the use of the reference stack API to avoid the problem of infinite recursive traversal when the object itself is referenced:
\begin{lstlisting}[language=c, style=berry]
int list_traversal(bvm *vm)
{
    // ...
    if (be_refcontains(vm, 1)) {
        be_return(vm);
    }
    be_refpush(vm, 1);
    // Traversing the container, may call list_traversal recursively.
    be_refpop(vm);
    be_return(vm);
}
\end{lstlisting}
This is a simplified traversal process of the List container. For the complete code, please refer to the source code of the function \texttt{m\_tostring} in \textsl{be\_listlib.c}. We assume that the index of the List object is \texttt{1}. First, we check whether the List already exists in the reference stack (line 4), and if the reference already exists, return directly, otherwise proceed with subsequent processing. To make \texttt{be\_refcontains} usable, we need to use \texttt{be\_refpush} and \texttt{be\_refpop} to process the reference stack before and after the actual traversal operation (lines 7 and 9).

\ffititle{be\_stack\_require}

This function tests the amount of free space on the stack and expands the stack space if it is insufficient. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_stack_require(bvm *vm, int count);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{count} is the required free stack capacity. If the free capacity of the virtual stack allocated by the VM to the native function is lower than this value, an expansion operation will be performed.

\ffititle{be\_isnil}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is \texttt{nil}, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isnil(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_isbool}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is of type \texttt{bool}, if it is, the function returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isbool(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_isint}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is an integer type, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isint(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_isreal}This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is a real number type, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isreal(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_isnumber}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is an integer or a real number type, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isnumber(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_isstring}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is a string type, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isstring(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_isclosure}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is a closure type, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isclosure(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_isntvclos}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is a primitive closure type, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isntvclos(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_isfunction}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is a function type, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isfunction(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured. There are three types of functions: closure, native function and native closure.

\ffititle{be\_isproto}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is of type \texttt{proto}, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isproto(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured. \texttt{proto} The type is the function prototype of the Berry closure.

\ffititle{be\_isclass}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is of type \texttt{class}, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isclass(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_isinstance}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is of type \texttt{instance}, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isinstance(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_islist}This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is of type \texttt{list}, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_islist(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_ismap}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is of type \texttt{map}, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_ismap(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_iscomptr}

This function returns whether the value indexed by the parameter \texttt{index} in the virtual stack is a universal pointer type, if it is, it returns \texttt{1}, otherwise it returns \texttt{0}. The prototype of this function is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_iscomptr(bvm *vm, int index);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance, and \texttt{index} is the index of the value to be measured.

\ffititle{be\_toint}

Get the value of the index position of \texttt{index} from the virtual stack and return it as an integer type. This function does not check the correctness of the type.

\ffititle{be\_toreal}

Get the value of the index position of \texttt{index} from the virtual stack and return it as a floating-point number type. This function does not check the correctness of the type.

\ffititle{be\_toindex}

Get the value of the index position of \texttt{index} from the virtual stack and return it as an integer type. This function does not check the correctness of the type. Unlike \texttt{be\_toint}, the return value type of \texttt{be\_toindex} is \texttt{int}, while the return value of the former is \texttt{bint}.

\ffititle{be\_tobool}

Get the value of the index position of \texttt{index} from the virtual stack and return it as a Boolean type. If the indexed value is not of Boolean type, it will be converted according to the rules in section \ref{section::type_bool}, and the conversion process will not cause the indexed value to change.

\ffititle{be\_tostring}

Get the value of the index position of \texttt{index} from the virtual stack and return it as a string type. If the indexed value is not a string type, the indexed value will be converted to a string, and the conversion process will replace the value at the indexed position in the virtual stack with the converted string. The string returned by this function always ends with \texttt{'\textbackslash 0'} characters.

\ffititle{be\_tocomptr}

Get the value of the index position of \texttt{index} from the virtual stack and return it as a general pointer type. This function does not check the correctness of the type.

\ffititle{be\_pushnil}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushnil(bvm *vm);
\end{lstlisting}

Push a \texttt{nil} value onto the virtual stack.

\ffititle{be\_pushbool}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushbool(bvm *vm, int b);
\end{lstlisting}

Push a Boolean value onto the virtual stack. The parameter \texttt{b} is the boolean value to be pushed onto the stack. When the value is \texttt{0}, it means false, otherwise it is true.

\ffititle{be\_pushint}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushint(bvm *vm, bint i);
\end{lstlisting}

Push an integer value \texttt{i} onto the virtual stack.

\ffititle{be\_pushreal}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushreal(bvm *vm, breal r);
\end{lstlisting}

Push a floating point value \texttt{r} onto the virtual stack.

\ffititle{be\_pushstring}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushstring(bvm *vm, const char *str)
\end{lstlisting}

Push the string \texttt{str} onto the virtual stack. The parameter \texttt{str} must point to a C string that ends with a null character \texttt{'\textbackslash 0'}, and a null pointer cannot be passed in.

\ffititle{be\_pushnstring}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushnstring(bvm *vm, const char *str, size_t n);
\end{lstlisting}Push the string \texttt{str} of length \texttt{n} onto the virtual stack. The length of the string is subject to the parameter \texttt{n}, and the null character is not used as the end mark of the string.

\ffititle{be\_pushfstring}

\begin{lstlisting}[language=c, style=berry, numbers=none]
const char* be_pushfstring(bvm *vm, const char *format, ...);
\end{lstlisting}

Push the formatted string into the virtual stack. The parameter \texttt{format} is a formatted string, which contains the text to be pushed onto the stack, and the \texttt{format} parameter contains a label, which can be replaced by the value specified by the subsequent additional parameter and formatted as required. \texttt{format} The rule for tag attributes is \textsf{\%specifier}, and Table \ref{tab::format_specifier} gives the meaning of each field. According to the label of the \texttt{format} string, a series of additional parameters may be required, and each additional parameter will replace the corresponding \texttt{\%} label in the \texttt{format} parameter.
\begin{table}[htb]
    \centering
    \setlength{\tabcolsep}{3mm}
    \begin{tabular}{cll} \toprule
        \textbf{\textsf{specifier}} & \textbf{Description} \\ \midrule
        \texttt{d} & Format as decimal signed integer (positive numbers do not output sign) \\
        \texttt{f} & Single or double precision floating point number formatted as a decimal \\
        \texttt{g} & Single or double precision floating point number formatted as exponential \\
        \texttt{s} & Format as string \\
        \texttt{c} & Format as a single character \\
        \texttt{p} & Format as pointer address \\
        \texttt{\%} & Escaped as \texttt{\%} Character (no parameter) \\
        \bottomrule
    \end{tabular}
    \caption{\texttt{format} Label parameter description}
    \label{tab::format_specifier}
\end{table}

\texttt{be\_pushfstring} The function is similar to the standard function of C \texttt{printf}, but the function of formatting strings is relatively basic and does not support operations such as customizing the width and decimal places. A typical example is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
be_pushfstring(vm, "%s: %d", "hello", 12); // Good, it works!
be_pushfstring(vm, "%s: %.5d", "hello", 12); // Error, the specified width is not supported.
\end{lstlisting}
This means that \texttt{be\_pushfstring} can only perform simple formatting operations. If the requirements cannot be met, it is recommended to use \texttt{sprintf} formatted strings for operations.

\ffititle{be\_pushvalue}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushvalue(bvm *vm, int index);
\end{lstlisting}

Push the value with index \texttt{index} onto the top of the virtual stack.

\ffititle{be\_pushntvclosure}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushntvclosure(bvm *vm, bntvfunc f, int nupvals);
\end{lstlisting}

Push a native closure onto the top of the virtual stack. The parameter \texttt{f} is the C function pointer of the native closure, and \texttt{nupvals} is the upvalue number of the closure.

\ffititle{be\_pushntvfunction}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushntvfunction(bvm *vm, bntvfunc f);
\end{lstlisting}

Push a native function onto the top of the virtual stack, and the parameter \texttt{f} is the native function pointer.

\ffititle{be\_pushclass}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushclass(bvm *vm, const char *name, const bnfuncinfo *lib);
\end{lstlisting}

Push a native class onto the top of the virtual stack. The parameter \texttt{name} is the name of the native class, and the parameter \texttt{lib} is the attribute description of the native class.

\ffititle{be\_pushcomptr}

\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pushcomptr(bvm *vm, void *ptr);
\end{lstlisting}

Push a general pointer onto the top of the virtual stack. The general pointer \texttt{ptr} points to a certain C data area. Since the content pointed to by this pointer is not maintained by Berry's garbage collector, users have to maintain the life cycle of the data themselves.

\ffititle{be\_pushiter}

Push an iterator onto the top of the virtual stack.

\ffititle{be\_pusherror}

Push an error message onto the top of the stack. After executing the FFI, the interpreter will directly return to the position that can handle the error, and the code immediately following will not be executed. The function prototype is:
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pusherror(bvm *vm, const char *msg);
\end{lstlisting}
The parameter \texttt{vm} is the pointer of the virtual machine instance; \texttt{msg} is the string containing the error information.

\ffititle{be\_moveto}

Move the value at the \texttt{from} index to the \texttt{to} index position. This function does not delete the value of \texttt{from} index position, only modifies the value of \texttt{to} index position.

\ffititle{be\_call}
\ffititle{be\_pcall}
\ffititle{be\_abort}
\ffititle{be\_exit}
\ffititle{be\_regfunc}
\ffititle{be\_regclass}

\section{Compile-time construction technology} \label{section::precompiled_build}

\textbf{caveat}: Due to code changes, the content described in this section is out of date. The current version (V0.1.3) has merged the \textsl{str\_build} tool and the \textsl{map\_build} tool, and the command format has been modified.The compile-time construction technology allows the Berry interpreter to construct native objects at compile time to reduce the memory overhead caused by dynamically constructing objects during the runtime of the interpreter. The compile-time construction technology has brought a number of performance indicators to improve, but the implementation of this technology needs to rely on external tools to generate the C code of the interpreter, which may have a slight barrier to use.

The compile-time construction technology is mainly implemented by \textsl{map\_build} and \textsl{str\_build} tools, which are located in the \textsl{tools/map\_build} path and \textsl{tools/str\_build} path of the interpreter source code directory. \textsl{str\_build} Tools are used to generate constant strings, and \textsl{map\_build} is used to generate constant objects. These constant strings and constant objects will be generated by these tools as C code, and will be compiled into constants when the interpreter is compiled. In principle, the \textsl{map\_build} and \textsl{str\_build} tools will generate code from the declaration information of the constant object (in accordance with a specific format). The process will automatically calculate the Hash value and generate the Hash table.

\textsl{Makefile} in the root directory of the interpreter project will automatically compile these tools and run the tools before compiling the interpreter source code. The content of \textsl{Makefile} ensures that when using the \texttt{make} command, the code for constructing the object at compile time will always be updated through the tool (if it needs to be updated). The code for constructing objects at compile time can be manually generated through the \texttt{make prebuild} command, which is stored in the \textsl{generate} folder.

The compile-time construction can be turned on or off by modifying the \texttt{BE\_USE\_PRECOMPILED\_OBJECT} macro. In any case, the tools \textsl{str\_build} and \textsl{map\_build} are called to generate constant object codes (the codes are not used when compile-time construction is turned off).

\subsubsection {Use command}

\texttt{map\_build} Tools are used to generate code for constant objects. The format of the command is
\begin{lstlisting}[language=bash, numbers=none]
map_build dst_path src_path
\end{lstlisting}
The output path \textsl{dst\_path} is used to store the generated code, and the source path \textsl{src\_path} is a list of paths that need to be scanned for the source code (use spaces to separate multiple paths). Since \textsl{generate} is used as the generated code path in the source code of the interpreter, \textsl{dst\_path} must be \textsl{generate}. Taking the standard interpreter project as an example, the command to use the tool in \texttt{map\_build} should be
\begin{lstlisting}[language=bash, numbers=none]
map_build generate src default
\end{lstlisting}
The meaning of this command is: the output path is \textsl{generate}, and the source path is \textsl{src} and \textsl{default}.

\texttt{str\_build} The tool is used to generate code for the constant string table.
\begin{lstlisting}[language=bash, numbers=none]
str_build dst_path src_path
\end{lstlisting}
Unlike \texttt{map\_build}, \texttt{str\_build} also needs to scan the constant object code generated by the former to generate a complete constant string table, so the \textsl{generate} path must be included in the source path list.
\begin{lstlisting}[language=bash, numbers=none]
str_build generate src default generate
\end{lstlisting}

\subsubsection {output path}

Strictly speaking, the \textsl{generate} folder used as the output path cannot be placed anywhere, it must be stored in a parent directory containing the path. The include path refers to the path where the header file will be searched in the project. Taking the standard interpreter source code as an example, the include path is \textsl{src} and \textsl{default}. Therefore, in the standard interpreter project, the \textsl{generate} folder is stored in the root directory of the interpreter source code (the parent directory of \textsl{src} and \textsl{default}).

The reason for the above rules is that the following codes are used in the interpreter source code to refer to constant objects:
\begin{lstlisting}[language=c, numbers=none]
#include "../generate/be_fixed_xxx.h"
\end{lstlisting}

If readers want to define constant objects themselves, they also need to use such code to include the corresponding header files. This section will introduce how to use these tools to define and use constant objects.

\subsection{Compile-time string table}

The compile-time string table is used to store constant strings. Constant strings are objects that are transparent to the script. They are not created or destroyed when the interpreter is running, but are always stored as constants in the data segment of the interpreter program. If you need to use a string as a constant string, you can add the prefix \texttt{be\_const\_str\_} in front of the string in the interpreter source code, and the declaration can be placed anywhere in the source file (including comments). For example, to create a constant string with the content \texttt{"string"}, you need to declare the symbol \texttt{be\_const\_str\_string} in the source file, and this symbol is also the variable name that refers to the constant string in the C code.

All keywords will create constant strings. If you modify the keyword-related code in the Berry interpreter, the corresponding code in \textsl{str\_build} must also be modified.

If the string contains special symbols, it cannot be expressed as a constant string, because the correct C variable name cannot be written. However, the name of a certain type of string containing special symbols can be written, and the special symbols must be escaped at this time. The following strings can be escaped:\begin{itemize}
    \item For a string beginning with the character \texttt{'.'}, all characters after \texttt{'.'} must be letters, numbers or underscores. \texttt{'.'} The character is escaped to \texttt{dot\_}.
    \item Operators that can be overloaded.
\end{itemize}

\subsubsection {Use constant string}

Normally, there is no need to manually declare constant strings, nor to use them manually. If you really need to call the constant string manually, include the header file \textsl{be\_constobj.h} to use all constant string variables (this header file has declarations for all constant strings). The typical use of constant strings is to construct objects at compile time. The declaration and definition of constant strings in this process are automatically handled by the tool.

In any case, the FFI function \texttt{be\_pushstring} should be used directly to create a string. When a string has a constant string, it will not repeatedly create a new string object, but directly use the corresponding constant string.

\subsection {Construct object at compile time}

Objects constructed at compile time are also called constant objects. The data structure of these objects is constructed when the interpreter is compiled and cannot be modified at runtime. \texttt{map\_build} A set of declaration rules is defined in the tool to generate C code for constant objects. The declaration information of the constant object is directly stored in the source file (\textsl{*.c}). In order to distinguish it from other content, a complete declaration information should be included in the following boot code:
\begin{lstlisting}[numbers=none]
@const_object_info_begin
@const_object_info_end
\end{lstlisting}
The constant object declaration information does not conform to the C language syntax, so they should be placed in a multi-line comment (included with \texttt{/* */}). All constant objects have the same declaration form. The declaration structure of a constant object is called "object declaration block", which is composed of
\begin{lstlisting}[numbers=none]
type object_name (attributes) {
    member_fields
}
\end{lstlisting}
\texttt{type} is the type of constant object, it can be \texttt{map}, \texttt{class}, \texttt{module} or \texttt{vartab}. \texttt{object\_name} is the variable name of the constant object in C language. \texttt{attributes} is the attribute list of constant objects. An attribute is composed of attribute name and attribute value. The attribute name and attribute value are separated by semicolons, and multiple attributes are separated by commas. For example, the attribute list \texttt{scope: global, name: map} means that the \texttt{scope} attribute of a constant object is \texttt{global}, and the \texttt{name} attribute is \texttt{map}. \texttt{member\_fields} is the list of member domains of constant objects. A member is composed of name and value, separated by commas. Each line can declare one member, and multiple members must be declared on multiple lines.

\textsl{map\_build} The tool uses regular expressions to parse the object declaration block. In the parsing process, the entire object declaration block will be matched first, and the information \texttt{type} and \texttt{object\_name} will be matched. For the information of \texttt{attributes} and \texttt{member\_fields}, further Analysis. In order to facilitate the implementation, the tool does not have strict requirements on the syntax of the object declaration block, and lacks a complete error handling mechanism, so you should ensure that the syntax is correct when writing the object declaration block.

In order to facilitate understanding, we illustrate with a simple constant class:
\begin{lstlisting}[language=c]
/* @const_object_info_begin
class be_class_map (scope: global, name: map) {
    .data, var
    init, func(m_init)
    tostring, func(m_tostring)
}
@const_object_info_end */
#include "../generate/be_fixed_be_class_map.h"
\end{lstlisting}
In this example, the declaration information of the entire constant class is in the C language comment, so it will not affect the compilation of the C code. The object declaration block is placed between \texttt{@const\_object\_info\_begin} and \texttt{@const\_object\_info\_end} to ensure that the tool \textsl{map\_build} The object declaration block can be recognized.

Since it is a constant class declaration, the value of \textsl{type} in the object declaration block is \texttt{class}, and \texttt{be\_class\_map} is the variable name of the constant object in the C code. Two attributes are declared in the attribute list of the object (the part enclosed in parentheses), and the meaning of these attributes will be introduced in the "Compile-Time Construction Class" section of this section. Three members are defined in the member list surrounded by curly braces, multiple members are separated by newlines, and the name of the member and the value of the member are separated by a comma.There are several legal formats for member names:
\begin{itemize}
    \item Berry variable name format: start with a letter or underscore, followed by several letters, underscores or numbers.
    \item Use ``\texttt{.}'' as the first character, followed by letters, underscores or numbers.
    \item Overloadable operators, such as ``\texttt{+}'', ``\texttt{-}'' and ``\texttt{<<}'' etc.
\end{itemize}
The value of a member can be of the following types:
\begin{itemize}
    \item \texttt{var}: This symbol will be compiled into an integer object (\texttt{be\_const\_int}), and the value of the integer object is automatically incremented from \texttt{0}. \texttt{var} It is designed for the declaration of member variables in the class, and its automatic numbering feature is used to realize the serial number of member variables.
    \item \texttt{func(symbol)}: Declare native member functions or methods of constant objects. The symbol will be compiled into a native function value (\texttt{be\_const\_func}), \texttt{symbol} is the native function pointer corresponding to the member. \texttt{m\_init} and \texttt{m\_tostring} in the example are two native functions.
    \item \texttt{int(value)}: This symbol will be compiled into an integer object (\texttt{be\_const\_int}), the value of the integer object is \texttt{value}.
    \item \texttt{real(value)}: This symbol will be compiled into a real number object (\texttt{be\_const\_real}), the value of the real number object is \texttt{value}.
    \item \texttt{real(value)}: This symbol will be compiled into a real number object (\texttt{be\_const\_int}), the value of the real number object is \texttt{value}.
    \item \texttt{class(symbol)}: This symbol will be compiled into a class object (\texttt{be\_const\_class}). \texttt{symbol} is a pointer to this type of object, and the pointer needs to point to a constant type object.
    \item \texttt{module(symbol)}: This symbol will be compiled into a module object (\texttt{be\_const\_module}). \texttt{symbol} is a pointer to the module object, and the pointer needs to point to a constant module object.
\end{itemize}

In order to use the \texttt{be\_class\_map} object, we need to include the corresponding header file in the C code to ensure that the object will be compiled. The usual practice is to include the corresponding header file near the object declaration block. In the example, line 8 contains it. The corresponding header file can be used to construct \texttt{be\_class\_map} objects at compile time.

After processing by the tool \textsl{map\_build}, each object declaration block will be compiled into a header file named \textsl{be\_fixed\_be\_xxx.h}, and \textsl{xxx} is the C variable name of the object. In order to compile constant objects in C code, we need to include the corresponding header files. It is usually recommended to include the corresponding header files near the object declaration block. The 8th line in the example contains \textsl{be\_fixed\_be\_class\_map.h} to construct the \texttt{be\_class\_map} object at compile time.

\subsubsection {Construct Map at Compile Time}

Maps constructed at compile-time are also constant \texttt{map} objects. They are generally not declared directly using object declaration blocks, but are declared in other compile-time construction structures. When constructing the constant \texttt{map}, the constant object type information should be \texttt{map}, which supports a \texttt{scope} attribute. When the \texttt{scope} attribute value is \texttt{local}, the constant object is \texttt{static}, the attribute When it is \texttt{global}, it is \texttt{extern}, and the value of this attribute is \texttt{local} by default. The constant \texttt{map} object's \texttt{member\_fields} supports common member name/member value specifications, and member values   are only stored as data without special interpretation. The following is an example of using the object declaration block to directly declare a constant \texttt{map} object:
\begin{lstlisting}
map map_name (scope: local/global) {
    init, func(m_init)
}
\end{lstlisting}

\subsubsection{Compile-time construction class}

To construct a class at compile time, use the object declaration block to declare, and the type information of the object is \texttt{class}. The declared properties of this object are \texttt{scope} and \texttt{name}. \texttt{scope} The scope of the C variable of the attribute declaration object, when the value is \texttt{local} (default), the scope is \texttt{static}, when it is \texttt{global}, the scope is \texttt{extern}; \texttt{name} The value of the attribute is that class Name, anonymous class can omit this parameter. Since the attribute list of a class only stores methods and member variable indexes, the \texttt{member\_fields} of the class constructed at compile time can only use the values   \texttt{var} and \texttt{func()}. A simple compile-time construction class declaration block is:
\begin{lstlisting}
class be_class_map (scope: global, name: map) {
    .data, var
    init, func(m_init)
    tostring, func(m_tostring)
}
\end{lstlisting}

\subsubsection {Building Module at Compile Time}

The type information of the building block declaration block at compile time is \texttt{module}.\begin{lstlisting}
module math (scope: global) {
    sin, func(m_sin)
    cos, func(m_cos)
    pi, real(M_PI)
}
\end{lstlisting}

\subsubsection {Construct Built-in Domain at Compile Time}

\begin{lstlisting}
vartab m_builtin (scope: local) {
    assert, func(l_assert)
    print, func(l_print)
    list, class(be_class_list)
}
\end{lstlisting}

\section {Module}

This function is not perfect yet.